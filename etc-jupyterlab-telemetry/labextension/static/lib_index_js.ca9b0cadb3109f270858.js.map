{"version":3,"sources":["webpack://etc-jupyterlab-telemetry/./lib/index.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;AAA0D;AACjB;AACe;AACD;AACvD;AACA,iBAAiB,6EAA6E;AAC9F;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kFAAgC;AACxC;AACA,QAAQ,uDAAI;AACZ;AACA,8FAA8F,kBAAkB,EAAE;AAClH;AACA,SAAS;AACT;AACA;AACA,QAAQ,qFAAmC;AAC3C;AACA,uBAAuB,iCAAiC;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA,SAAS;AACT;AACA;AACA;AACA,uCAAuC,qBAAqB;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA,uBAAuB,4CAA4C;AACnE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY,uDAAI;AAChB,8FAA8F,kBAAkB,EAAE;AAClH,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,kEAAgB;AACxB,QAAQ,oEAAgB;AACxB;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC,gBAAgB;AACtD,SAAS;AACT;AACA;AACA;AACA,iEAAe,SAAS,EAAC","file":"lib_index_js.ca9b0cadb3109f270858.js","sourcesContent":["import { IDocumentManager } from \"@jupyterlab/docmanager\";\nimport { each } from \"@lumino/algorithm\";\nimport { INotebookTracker } from \"@jupyterlab/notebook\";\nimport { NotebookActions } from '@jupyterlab/notebook';\nclass EventMessage {\n    constructor({ eventName, notebookModel, cellModels, notebookMeta, timestamp, user, debug }) {\n        this.eventName = eventName;\n        this.notebookModel = notebookModel;\n        this.cellModels = cellModels;\n        this.notebookMeta = notebookMeta;\n        this.timestamp = timestamp;\n        this.user = user;\n        this.debug = debug;\n    }\n}\nclass NotebookPanelWrapper {\n    constructor({ notebookPanel }) {\n        this._notebookPanel = notebookPanel;\n        notebookPanel.content.node.addEventListener(\"scroll\", this.scroll.bind(this));\n        this._cells = notebookPanel.model.cells;\n        this._notebookPanel.content.model.cells.changed.connect(this.cellsChanged, this);\n        this._notebookPanel.context.saveState.connect(this.saveState, this);\n        this._notebookPanel.sessionContext.sessionChanged.connect(this.sessionChanged, this);\n        NotebookActions.executed.connect(this.executed, this);\n        this._notebookPanel.disposed.connect(this._dispose, this);\n        each(this._cells, (cell, index) => {\n            if (!cell.metadata.get(\"etc_hash\")) {\n                this.hashCell(cell).then((r) => cell.metadata.set('etc_hash', r)).catch(j => { console.error(j); });\n            }\n        });\n    }\n    _dispose() {\n        NotebookActions.executed.disconnect(this.executed, this);\n        delete this._cells;\n        console.log(`${this._notebookPanel.context.path} disposed.`);\n        delete this._notebookPanel;\n    }\n    scroll(e) {\n        clearTimeout(this._scrollTimeoutID);\n        this._scrollTimeoutID = setTimeout(() => {\n            let cells = [];\n            this._notebookPanel.content.widgets.forEach((cell) => {\n                if ((cell.node.offsetTop + cell.node.offsetHeight) > e.target.scrollTop) {\n                    cells.push(cell.model);\n                }\n            });\n            let eventMessage = new EventMessage({\n                eventName: \"Scroll finished.\",\n                notebookModel: this._notebookPanel.model,\n                cellModels: cells,\n                notebookMeta: this._notebookPanel.model.metadata,\n                timestamp: Date.now(),\n                user: this._user\n            });\n            this.logMessage(eventMessage);\n        }, 1000);\n    }\n    async logMessage(eventMessage) {\n        try {\n            let data = JSON.stringify({ data: eventMessage });\n            console.log(eventMessage.eventName, data);\n            let response = await fetch(\"https://293p82kx3j.execute-api.us-east-1.amazonaws.com/adpatter-api-aws-edtech-labs-si-umich-edu/adpatter-s3-aws-edtech-labs-si-umich-edu/test\", {\n                method: \"POST\",\n                mode: \"cors\",\n                cache: \"no-cache\",\n                headers: {\n                    \"Content-Type\": \"application/json\"\n                    // \"Content-Type\": \"application/x-www-form-urlencoded\",\n                },\n                redirect: \"follow\",\n                referrerPolicy: \"no-referrer\",\n                body: data // body data type must match \"Content-Type\" header\n            });\n            if (!response.ok) {\n                let headers = {};\n                try {\n                    response.headers.forEach((value, key) => {\n                        headers[key] = value;\n                    });\n                }\n                catch (_a) {\n                    // forEach is iffy in the API. \n                }\n                throw new Error(JSON.stringify({\n                    \"response.status\": response.status,\n                    \"response.statusText\": response.statusText,\n                    \"response.text()\": await response.text(),\n                    \"response.headers\": headers\n                }));\n            }\n        }\n        catch (e) {\n            console.error(e);\n        }\n    }\n    getCell(cellId) {\n        for (let i = 0; i < this._notebookPanel.model.cells.length; i = i + 1) {\n            let cell = this._notebookPanel.model.cells.get(i);\n            if (cell.id == cellId) {\n                return cell;\n            }\n        }\n    }\n    sessionChanged(sessionContext, changedArgs) {\n        var _a, _b;\n        (_b = (_a = changedArgs === null || changedArgs === void 0 ? void 0 : changedArgs.newValue) === null || _a === void 0 ? void 0 : _a.kernel) === null || _b === void 0 ? void 0 : _b.anyMessage.connect((kernelConnection, anyMessageArgs) => {\n            var _a, _b;\n            if (!this._user && anyMessageArgs.direction == \"recv\" && ((_b = (_a = anyMessageArgs === null || anyMessageArgs === void 0 ? void 0 : anyMessageArgs.msg) === null || _a === void 0 ? void 0 : _a.header) === null || _b === void 0 ? void 0 : _b.username) !== \"\") {\n                this._user = anyMessageArgs.msg.header.username;\n            }\n        });\n    }\n    executed(_, arg) {\n        if (arg.notebook.model === this._notebookPanel.model) {\n            let cell = arg.cell;\n            let eventMessage = new EventMessage({\n                eventName: \"Execution finished.\",\n                notebookModel: this._notebookPanel.model,\n                cellModels: [cell.model],\n                notebookMeta: this._notebookPanel.model.metadata,\n                timestamp: Date.now(),\n                user: this._user\n            });\n            this.logMessage(eventMessage);\n        }\n    }\n    async hashCell(cell) {\n        let outputs = \"\";\n        if (cell.type === \"code\") {\n            outputs = JSON.stringify(cell.outputs.toJSON());\n        }\n        let input = cell.value.text;\n        let uInt8Array = (new TextEncoder()).encode(input + outputs);\n        let arrayBuffer = await crypto.subtle.digest(\"SHA-256\", uInt8Array);\n        return Array.from(new Uint8Array(arrayBuffer)).map(cur => cur.toString(16).padStart(2, \"0\")).join(\"\");\n    }\n    saveState(context, saveState) {\n        if (saveState == \"started\") {\n            each(this._cells, (cell, index) => {\n                this.hashCell(cell).then((r) => cell.metadata.set('etc_hash', r)).catch(j => { console.error(j); });\n            });\n        }\n        if (saveState == \"completed\") {\n            let eventMessage = new EventMessage({\n                eventName: \"Save a notebook.\",\n                notebookModel: this._notebookPanel.model,\n                cellModels: this._notebookPanel.content.widgets.filter((cell) => this._notebookPanel.content.isSelectedOrActive(cell)).map((value) => value.model),\n                notebookMeta: this._notebookPanel.model.metadata,\n                timestamp: Date.now(),\n                user: this._user\n            });\n            this.logMessage(eventMessage);\n        }\n    }\n    cellsChanged(cells, changed) {\n        let eventMessage;\n        switch (changed.type) {\n            case \"remove\":\n                eventMessage = new EventMessage({\n                    eventName: \"Delete a cell.\",\n                    notebookModel: this._notebookPanel.model,\n                    cellModels: changed.oldValues,\n                    notebookMeta: this._notebookPanel.model.metadata,\n                    timestamp: Date.now(),\n                    user: this._user\n                });\n                break;\n            case \"add\":\n                eventMessage = new EventMessage({\n                    eventName: \"Create a cell.\",\n                    notebookModel: this._notebookPanel.model,\n                    cellModels: changed.newValues,\n                    notebookMeta: this._notebookPanel.model.metadata,\n                    timestamp: Date.now(),\n                    user: this._user\n                });\n                break;\n            default:\n                break;\n        }\n        if (eventMessage) {\n            this.logMessage(eventMessage);\n        }\n        else {\n            console.error(\"Undefined changed.type: \", changed.type);\n        }\n    }\n}\n/**\n * Initialization data for the etc-jupyterlab-telemetry extension.\n */\nconst extension = {\n    id: \"etc-jupyterlab-telemetry:plugin\",\n    autoStart: true,\n    requires: [\n        INotebookTracker,\n        IDocumentManager\n    ],\n    activate: (app, notebookTracker, documentManager) => {\n        console.log(\"JupyterLab extension etc-jupyterlab-telemetry is activated!\");\n        notebookTracker.widgetAdded.connect(async (tracker, notebookPanel) => {\n            await notebookPanel.revealed;\n            await notebookPanel.sessionContext.ready;\n            new NotebookPanelWrapper({ notebookPanel });\n        });\n        return {};\n    }\n};\nexport default extension;\n"],"sourceRoot":""}